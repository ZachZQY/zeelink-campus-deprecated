/**
 * PostgreSQL数据库SQL脚本生成器
 * 
 * 该脚本从tables目录读取表配置，生成完整的PostgreSQL SQL脚本
 * 包括表创建、关系建立、视图创建、序列重置和初始数据
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

// 在ES模块中获取当前文件的路径
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// 定义接口
interface Field {
  name: string;
  type: string;
  primary?: boolean;
  nullable?: boolean;
  default?: string;
  unique?: boolean;
  check?: string;
  description?: string;
  enumValues?: string[];
  enumName?: string;
}

interface Relation {
  targetTable: string;
  type: 'ONE_TO_ONE' | 'ONE_TO_MANY' | 'MANY_TO_ONE' | 'MANY_TO_MANY';
  relationNameInCurrentTable: string;
  relationNameInTargetTable: string;
  onDelete?: string;
  onUpdate?: string;
  description?: string;
}

interface Index {
  fields: string[];
  unique?: boolean;
  where?: string;
}

interface TableConfig {
  tableName: string;
  description?: string;
  fields: Field[];
  relations?: Relation[];
  indexes?: Index[];
}

// 定义校验错误接口
interface ValidationError {
  table: string;
  relation?: Relation;
  field?: Field;
  relatedTable?: string;
  errorType: string;
  message: string;
  suggestion?: string;
}

// 自动生成的字段
const autoGeneratedFields: Field[] = [
  { name: 'created_at', type: 'TIMESTAMPTZ', nullable: false, default: 'CURRENT_TIMESTAMP', description: '创建时间' },
  { name: 'updated_at', type: 'TIMESTAMPTZ', nullable: false, default: 'CURRENT_TIMESTAMP', description: '更新时间' }
];

// 辅助函数：提取SQL基本类型
function extractBaseType(type: string): string {
  // 移除数组标记
  if (type.endsWith('[]')) {
    return 'ARRAY';
  }
  
  // 处理带参数的类型，如 VARCHAR(255)
  const match = type.match(/^([A-Z_]+)(?:\(.*\))?$/i);
  return match ? match[1].toUpperCase() : type.toUpperCase();
}

// 有效的字段类型列表
const validFieldTypes = [
  'TEXT',  
  'JSONB', 
  'TIMETZ', 
  'BIGINT', 
  'BIGSERIAL', 
  'TIMESTAMPTZ', 
  'DECIMAL', 
  'DATE',
  // 特殊自动字段
  'ID',
  'CREATED_AT',
  'UPDATED_AT'
];

// 加载所有表配置
async function loadAllTables(): Promise<TableConfig[]> {
  const tablesDir = path.join(__dirname, 'tables');
  const files = fs.readdirSync(tablesDir);
  const tables: TableConfig[] = [];
  const errors: string[] = [];
  
  for (const file of files) {
    if (file.endsWith('.ts') || file.endsWith('.js')) {
      try {
        const tableName = file.replace(/\.(ts|js)$/, '');
        
        const tableModule = await import(`./tables/${tableName}`);
        const table = tableModule.default;
        
        if (table && table.tableName && table.fields) {
          const hasCreatedAt = table.fields.some((f: Field) => f.name === 'created_at');
          const hasUpdatedAt = table.fields.some((f: Field) => f.name === 'updated_at');
          
          if (!hasCreatedAt) {
            table.fields.push(autoGeneratedFields[0]);
          }
          
          if (!hasUpdatedAt) {
            table.fields.push(autoGeneratedFields[1]);
          }
          
          tables.push(table);
        } else {
          errors.push(`表定义无效: ${file} - 缺少必要的属性(tableName或fields)`);
        }
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : '未知错误';
        errors.push(`加载表定义出错: ${file} - ${errorMessage}`);
      }
    }
  }
  
  if (errors.length > 0) {
    console.error('加载表定义时发生以下错误:');
    errors.forEach(error => console.error(`- ${error}`));
    console.error('这些错误的表定义将被跳过。');
  }
  
  return tables;
}

// 检查表定义的关系
function validateTableRelations(tables: TableConfig[], errors: ValidationError[]): void {
  const tableMap = new Map<string, TableConfig>();
  const foreignKeySet = new Set<string>(); 
  
  tables.forEach(table => {
    tableMap.set(table.tableName, table);
  });
  
  tables.forEach(table => {
    if (!table.relations) return;
    
    table.relations.forEach(relation => {
      if (relation.type === 'MANY_TO_ONE' || relation.type === 'MANY_TO_MANY') {
        errors.push({
          table: table.tableName,
          relation,
          errorType: 'INVALID_RELATION_TYPE',
          message: `表 "${table.tableName}" 中存在不符合单向原则的关系类型: "${relation.type}"`,
          suggestion: '根据单向原则，表定义中只应使用 ONE_TO_MANY 和 ONE_TO_ONE 类型的关系，不应直接定义 MANY_TO_ONE 或 MANY_TO_MANY。'
        });
      }
      
      if (!tableMap.has(relation.targetTable)) {
        errors.push({
          table: table.tableName,
          relation,
          relatedTable: relation.targetTable,
          errorType: 'MISSING_TARGET_TABLE',
          message: `表 "${table.tableName}" 引用了不存在的目标表 "${relation.targetTable}"`,
          suggestion: '检查表名拼写或创建缺失的表。'
        });
        return;
      }
      
      let foreignKeyColumn: string, sourceTable: string, targetTable: string;
      
      if (relation.type === 'ONE_TO_MANY') {
        targetTable = table.tableName;
        sourceTable = relation.targetTable;
        foreignKeyColumn = `${relation.relationNameInTargetTable}_${targetTable}`;
        
        const fkIdentifier = `${relation.targetTable}:${foreignKeyColumn}`;
        if (foreignKeySet.has(fkIdentifier)) {
          errors.push({
            table: table.tableName,
            relation,
            relatedTable: relation.targetTable,
            errorType: 'FOREIGN_KEY_CONFLICT',
            message: `表 "${table.tableName}" 定义的关系将生成冲突的外键: "${foreignKeyColumn}"`,
            suggestion: '修改relationNameInTargetTable以避免生成重复的外键名称。'
          });
        }
        foreignKeySet.add(fkIdentifier);
      } else {
        targetTable = relation.targetTable;
        sourceTable = table.tableName;
        foreignKeyColumn = `${relation.relationNameInTargetTable}_${targetTable}`;
        
        const fkIdentifier = `${table.tableName}:${foreignKeyColumn}`;
        if (foreignKeySet.has(fkIdentifier)) {
          errors.push({
            table: table.tableName,
            relation,
            relatedTable: relation.targetTable,
            errorType: 'FOREIGN_KEY_CONFLICT',
            message: `表 "${table.tableName}" 定义的关系将生成冲突的外键: "${foreignKeyColumn}"`,
            suggestion: '修改relationNameInTargetTable以避免生成重复的外键名称。'
          });
        }
        foreignKeySet.add(fkIdentifier);
      }
    });
  });
}

// 检查冗余关系
function detectDuplicateRelations(tables: TableConfig[]): ValidationError[] {
  const errors: ValidationError[] = [];
  
  tables.forEach(table => {
    if (table.relations) {
      // 按目标表分组
      const relationsByTarget: Record<string, Relation[]> = {};
      
      table.relations.forEach(relation => {
        const target = relation.targetTable;
        if (!relationsByTarget[target]) {
          relationsByTarget[target] = [];
        }
        relationsByTarget[target].push(relation);
      });
      
      // 检查每个目标表是否有重复关系
      for (const target in relationsByTarget) {
        const relations = relationsByTarget[target];
        if (relations.length > 1) {
          errors.push({
            table: table.tableName,
            relation: relations[0],
            relatedTable: target,
            errorType: 'REDUNDANT_RELATION',
            message: `发现冗余关系定义: ${table.tableName}.${relations[0].type} → ${target} 和 ${table.tableName}.${relations[1].type} → ${target}`,
            suggestion: '每个关系应该只在一处定义。请删除重复的关系定义。'
          });
        }
      }
    }
  });
  
  return errors;
}

// 检查外键冲突
function detectForeignKeyConflicts(tables: TableConfig[]): ValidationError[] {
  const errors: ValidationError[] = [];
  const foreignKeySet = new Set<string>();
  
  tables.forEach(table => {
    if (!table.relations) return;
    
    table.relations.forEach(relation => {
      let sourceTable: string, targetTable: string, foreignKeyColumn: string;
      
      if (relation.type === 'ONE_TO_MANY') {
        sourceTable = relation.targetTable;
        targetTable = table.tableName;
        foreignKeyColumn = `${relation.relationNameInTargetTable}_${targetTable}`;
      } else if (relation.type === 'ONE_TO_ONE' || relation.type === 'MANY_TO_ONE') {
        sourceTable = table.tableName;
        targetTable = relation.targetTable;
        foreignKeyColumn = `${relation.relationNameInTargetTable}_${targetTable}`;
      } else {
        return;
      }
      
      const fkIdentifier = `${sourceTable}:${foreignKeyColumn}`;
      if (foreignKeySet.has(fkIdentifier)) {
        errors.push({
          table: table.tableName,
          relation,
          relatedTable: relation.targetTable,
          errorType: 'FOREIGN_KEY_CONFLICT',
          message: `表 "${table.tableName}" 定义的关系将生成冲突的外键: "${foreignKeyColumn}"`,
          suggestion: '修改relationNameInTargetTable以避免生成重复的外键名称。'
        });
      }
      foreignKeySet.add(fkIdentifier);
    });
  });
  
  return errors;
}

// 校验表定义
function validateTableDefinitions(tables: TableConfig[]): ValidationError[] {
  const errors: ValidationError[] = [];
  
  // 检查表名重复
  const tableNameCounts = new Map<string, number>();
  tables.forEach(table => {
    const count = tableNameCounts.get(table.tableName) || 0;
    tableNameCounts.set(table.tableName, count + 1);
    
    if (count > 0) {
      errors.push({
        table: table.tableName,
        errorType: 'DUPLICATE_TABLE_NAME',
        message: `发现重复的表名: "${table.tableName}"`,
        suggestion: '请确保每个表名都是唯一的，检查tables目录中是否有多个文件定义了相同的表名。'
      });
    }
  });
  
  // 检查字段类型是否有效
  tables.forEach(table => {
    table.fields.forEach(field => {
      if (field.name === 'id' && field.primary) {
        return;
      }
      
      const fieldType = extractBaseType(field.type);
      
      if (!validFieldTypes.includes(fieldType)) {
        errors.push({
          table: table.tableName,
          field,
          errorType: 'INVALID_FIELD_TYPE',
          message: `表 "${table.tableName}" 中的字段 "${field.name}" 使用了不支持的类型: "${field.type}"`,
          suggestion: `有效的PostgreSQL字段类型包括: ${validFieldTypes.join(', ')}`
        });
      }
    });
  });
  
  // 检查关系定义是否合法
  validateTableRelations(tables, errors);
  
  // 检查冗余关系
  errors.push(...detectDuplicateRelations(tables));
  
  // 检查外键冲突
  errors.push(...detectForeignKeyConflicts(tables));
  
  return errors;
}

// 格式化校验错误
function formatValidationErrors(errors: ValidationError[]): string {
  if (errors.length === 0) {
    return '';
  }
  
  let output = '\n============== 表定义验证错误 ==============\n\n';
  
  // 按错误类型分组
  const errorsByType = new Map<string, ValidationError[]>();
  errors.forEach(error => {
    const errorList = errorsByType.get(error.errorType) || [];
    errorList.push(error);
    errorsByType.set(error.errorType, errorList);
  });
  
  // 先显示字段类型错误
  if (errorsByType.has('INVALID_FIELD_TYPE')) {
    output += '不支持的字段类型错误:\n';
    output += '------------------------\n';
    errorsByType.get('INVALID_FIELD_TYPE')!.forEach(error => {
      output += `表 "${error.table}" 中的字段 "${error.field!.name}" 使用了不支持的类型: "${error.field!.type}"\n`;
    });
    output += '\n在Zion中仅支持以下PostgreSQL字段类型:\n';
    output += '  ' + validFieldTypes.join(', ') + '\n\n';
  }
  
  // 显示其他类型的错误
  errorsByType.forEach((errorList, errorType) => {
    if (errorType === 'INVALID_FIELD_TYPE') return; // 已经处理过
    
    output += `${errorType} 错误:\n`;
    output += '------------------------\n';
    errorList.forEach(error => {
      output += `- ${error.message}\n`;
      if (error.suggestion) {
        output += `  建议: ${error.suggestion}\n`;
      }
    });
    output += '\n';
  });
  
  output += `发现 ${errors.length} 个错误，请修正后再次尝试。\n`;
  return output;
}

// 主函数
async function generateTableSQL(): Promise<void> {
  try {
    const tables = await loadAllTables();
    console.log(`加载了 ${tables.length} 个表定义.`);
    
    if (tables.length === 0) {
      console.error('没有找到有效的表定义，SQL生成中止。');
      return;
    }
    
    const validationErrors = validateTableDefinitions(tables);
    if (validationErrors.length > 0) {
      // 检查是否有字段类型错误
      const hasTypeErrors = validationErrors.some(error => error.errorType === 'INVALID_FIELD_TYPE');
      
      console.error(formatValidationErrors(validationErrors));
      
      if (hasTypeErrors) {
        console.error(`验证失败: 检测到不支持的字段类型。在Zion中，仅支持以下SQL类型:`);
        console.error(`  ${validFieldTypes.join(', ')}`);
        console.error('SQL生成已中止。请修正错误后重试。');
      } else {
        console.error('验证失败，SQL生成中止。');
      }
      return;
    }
    
    let sql = '';
    
    sql += generateHeader();
    sql += generateEnumSQL(tables);
    sql += generateCreateTableSQL(tables);
    sql += generateForeignKeysSQL(tables);
    sql += generateIndexesSQL(tables);
    sql += await generateTriggersSQL();
    // sql += await generateViewsSQL();  // 删除这一行
    sql += generateFooter();
    
    const outputDir = path.join(__dirname, 'outputs');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir);
    }
    
    fs.writeFileSync(path.join(outputDir, 'pg.sql'), sql);
    console.log(`SQL生成成功，已写入到 ${path.join(outputDir, 'database.sql')}`);
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('SQL生成过程中发生错误:', errorMessage);
  }
}

// 生成创建表的SQL
function generateCreateTableSQL(tables: TableConfig[]): string {
  let sql = '';
  
  for (const table of tables) {
    sql += `\n-- ============================================\n`;
    sql += `-- Table: ${table.tableName}\n`;
    sql += `-- Description: ${table.description || table.tableName}\n`;
    sql += `-- ============================================\n\n`;
    
    sql += `CREATE TABLE IF NOT EXISTS ${table.tableName} (\n`;
    
    const fieldDefinitions: string[] = [];
    
    // 如果用户没有定义id字段，则添加默认的id字段
    if (!table.fields.some(field => field.name === 'id')) {
      fieldDefinitions.push('  id BIGSERIAL PRIMARY KEY, -- 主键');
    }
    
    // 格式化用户定义的字段
    table.fields.forEach((field: Field) => {
      let definition = `  ${field.name} ${field.type}`;
      const constraints: string[] = [];
      
      if (field.primary) constraints.push('PRIMARY KEY');
      if (field.nullable === false) constraints.push('NOT NULL');
      if (field.default) constraints.push(`DEFAULT ${field.default}`);
      if (field.unique) constraints.push('UNIQUE');
      if (field.check) constraints.push(`CHECK (${field.check})`);
      
      if (constraints.length > 0) {
        definition += ` ${constraints.join(' ')}`;
      }
      
      definition += ',';
      
      if (field.description) {
        definition += ` -- ${field.description}`;
      }
      
      fieldDefinitions.push(definition);
    });
    
    // 添加时间戳字段
    if (!table.fields.some(f => f.name === 'created_at')) {
      fieldDefinitions.push('  created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP, -- 创建时间');
    }
    if (!table.fields.some(f => f.name === 'updated_at')) {
      fieldDefinitions.push('  updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP -- 更新时间');
    } else {
      // 确保最后一个字段没有逗号
      const lastField = fieldDefinitions[fieldDefinitions.length - 1];
      fieldDefinitions[fieldDefinitions.length - 1] = lastField.replace(',', '');
    }
    
    sql += fieldDefinitions.join('\n');
    sql += '\n);\n\n';
    
    // 添加表和字段注释
    sql += `-- Table Comments\n`;
    sql += `COMMENT ON TABLE ${table.tableName} IS '${table.description || table.tableName}';\n\n`;
    
    sql += `-- Column Comments\n`;
    if (!table.fields.some(f => f.name === 'id')) {
      sql += `COMMENT ON COLUMN ${table.tableName}.id IS '唯一标识符';\n`;
    }
    
    table.fields.forEach(field => {
      if (field.description) {
        sql += `COMMENT ON COLUMN ${table.tableName}.${field.name} IS '${field.description}';\n`;
      }
    });
    
    sql += '\n';
  }
  
  return sql;
}

function generateForeignKeysSQL(tables: TableConfig[]): string {
  let sql = '\n-- ============================================\n';
  sql += '-- Foreign Key Constraints\n';
  sql += '-- ============================================\n\n';
  
  const addedRelations = new Set<string>();
  
  for (const table of tables) {
    if (!table.relations?.length) continue;
    
    sql += `-- ${table.tableName} 表的外键关系\n`;
    
    for (const relation of table.relations) {
      let sourceTable: string, targetTable: string, foreignKeyColumn: string;
      
      if (relation.type === 'ONE_TO_MANY') {
        sourceTable = relation.targetTable;
        targetTable = table.tableName;
      } else {
        sourceTable = table.tableName;
        targetTable = relation.targetTable;
      }
      
      foreignKeyColumn = `${relation.relationNameInTargetTable}_${targetTable}`;
      const relationIdentifier = `${sourceTable}_TO_${targetTable}_${foreignKeyColumn}`;
      
      if (addedRelations.has(relationIdentifier)) continue;
      addedRelations.add(relationIdentifier);
      
      const constraintName = `fk_${sourceTable}_${targetTable}_${relation.relationNameInTargetTable}`;
      
      sql += `\n-- ${relation.description || `${sourceTable} -> ${targetTable} 关系`}\n`;
      sql += `ALTER TABLE ${sourceTable}\n`;
      sql += `    ADD COLUMN IF NOT EXISTS ${foreignKeyColumn} BIGINT,\n`;
      sql += `    ADD CONSTRAINT ${constraintName}\n`;
      sql += `        FOREIGN KEY (${foreignKeyColumn})\n`;
      sql += `        REFERENCES ${targetTable}(id)\n`;
      sql += `        ON DELETE SET NULL;\n\n`;
      
      sql += `COMMENT ON COLUMN ${sourceTable}.${foreignKeyColumn}\n`;
      sql += `    IS '外键：关联到 ${targetTable} 表';\n`;
    }
  }
  
  return sql;
}

function generateIndexesSQL(tables: TableConfig[]): string {
  let sql = '\n-- ============================================\n';
  sql += '-- Indexes\n';
  sql += '-- ============================================\n\n';
  
  tables.forEach(table => {
    sql += `-- ${table.tableName} 表索引\n`;
    
    // 用户定义的索引
    if (table.indexes?.length) {
      table.indexes.forEach(index => {
        const indexType = index.unique ? 'UNIQUE INDEX' : 'INDEX';
        const indexName = `idx_${table.tableName}_${index.fields.join('_')}`;
        
        sql += `\n-- ${index.fields.join(', ')} 字段的${index.unique ? '唯一' : ''}索引\n`;
        sql += `CREATE ${indexType} IF NOT EXISTS ${indexName}\n`;
        sql += `    ON ${table.tableName} (${index.fields.join(', ')})`;
        
        if (index.where) {
          sql += `\n    WHERE ${index.where}`;
        }
        
        sql += `;\n`;
      });
      sql += '\n';
    }
    
    // 自动创建的时间戳索引
    const hasUpdatedAtIndex = table.indexes?.some(idx => 
      idx.fields.includes('updated_at') || 
      idx.fields.some(f => f.toLowerCase().includes('updated_at'))
    );
    
    const hasCreatedAtIndex = table.indexes?.some(idx => 
      idx.fields.includes('created_at') || 
      idx.fields.some(f => f.toLowerCase().includes('created_at'))
    );
    
    if (!hasUpdatedAtIndex) {
      sql += `-- updated_at 字段索引\n`;
      sql += `CREATE INDEX IF NOT EXISTS idx_${table.tableName}_updated_at\n`;
      sql += `    ON ${table.tableName} (updated_at);\n\n`;
    }
    
    if (!hasCreatedAtIndex) {
      sql += `-- created_at 字段索引\n`;
      sql += `CREATE INDEX IF NOT EXISTS idx_${table.tableName}_created_at\n`;
      sql += `    ON ${table.tableName} (created_at);\n\n`;
    }
  });
  
  return sql;
}

// 生成触发器SQL
async function generateTriggersSQL(): Promise<string> {
  let sql = '';
  
  sql += `CREATE OR REPLACE FUNCTION update_timestamp()\n`;
  sql += `RETURNS TRIGGER AS $$\n`;
  sql += `BEGIN\n`;
  sql += `  NEW.updated_at = CURRENT_TIMESTAMP;\n`;
  sql += `  RETURN NEW;\n`;
  sql += `END;\n`;
  sql += `$$ LANGUAGE plpgsql;\n\n`;
  
  const tables = await loadAllTables();
  tables.forEach(table => {
    sql += `DROP TRIGGER IF EXISTS trg_${table.tableName}_update_timestamp ON ${table.tableName};\n`;
    sql += `CREATE TRIGGER trg_${table.tableName}_update_timestamp\n`;
    sql += `BEFORE UPDATE ON ${table.tableName}\n`;
    sql += `FOR EACH ROW\n`;
    sql += `EXECUTE FUNCTION update_timestamp();\n\n`;
  });
  
  return sql;
}

// 生成视图SQL
async function generateViewsSQL(): Promise<string> {
  let sql = '';
  
  // 获取表列表
  const tables = await loadAllTables();
  
  const hasUserTable = tables.some(t => t.tableName === 'user');
  const hasPostsTable = tables.some(t => t.tableName === 'posts');
  
  if (hasUserTable && hasPostsTable) {
    sql += `CREATE OR REPLACE VIEW user_posts_view AS\n`;
    sql += `  SELECT u.id AS user_id, u.nickname, u.avatar, p.id AS post_id, p.content, p.created_at\n`;
    sql += `  FROM "user" u\n`;
    sql += `  JOIN posts p ON p.posts_user = u.id\n`;
    sql += `  ORDER BY p.created_at DESC;\n\n`;
  }
  
  sql += `CREATE OR REPLACE VIEW user_detail AS\n`;
  sql += `SELECT \n`;
  sql += `  u.id, \n`;
  sql += `  u.username, \n`;
  sql += `  u.email, \n`;
  sql += `  u.created_at, \n`;
  sql += `  u.updated_at, \n`;
  sql += `  p.display_name, \n`;
  sql += `  p.avatar, \n`;
  sql += `  p.bio, \n`;
  sql += `  p.location \n`;
  sql += `FROM \n`;
  sql += `  "user" u \n`;
  sql += `  LEFT JOIN profile p ON u.id = p.user_id;\n\n`;
  
  return sql;
}

// 生成SQL头部
function generateHeader(): string {
  const now = new Date().toISOString();
  
  let sql = '';
  
  sql += `-- ======================================\n`;
  sql += `-- 数据库结构SQL脚本\n`;
  sql += `-- 生成时间: ${now}\n`;
  sql += `-- 生成工具: ZCM自动生成\n`;
  sql += `-- 注意: 此文件是自动生成的，请勿手动修改\n`;
  sql += `-- ======================================\n\n`;
  
  sql += `BEGIN;\n\n`;
  
  sql += `-- 设置时区为Asia/Shanghai\n`;
  sql += `SET timezone = 'Asia/Shanghai';\n\n`;
  
  return sql;
}

// 生成SQL底部
function generateFooter(): string {
  let sql = '';
  
  // 异常处理
  sql += `-- ======================================\n`;
  sql += `-- 检查表是否存在，设置最后一次执行时间\n`;
  sql += `-- ======================================\n\n`;
  
  sql += `DO $$\n`;
  sql += `BEGIN\n`;
  sql += `  IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'system_config') THEN\n`;
  sql += `    INSERT INTO system_config (key, value, description) \n`;
  sql += `    VALUES ('LAST_DB_SYNC', NOW()::text, '最后一次数据库同步时间') \n`;
  sql += `    ON CONFLICT (key) DO UPDATE SET value = NOW()::text;\n`;
  sql += `  END IF;\n`;
  sql += `END;\n`;
  sql += `$$;\n\n`;
  
  sql += `COMMIT;\n\n`;
  sql += `-- 执行完成\n`;
  
  return sql;
}

// 生成枚举类型的SQL
function generateEnumSQL(tables: TableConfig[]): string {
  let sql = `-- ======================================\n`;
  sql += `-- 枚举类型定义\n`;
  sql += `-- ======================================\n\n`;
  
  const enums = new Map<string, string[]>();
  
  tables.forEach(table => {
    table.fields.forEach(field => {
      if (field.enumValues && field.enumValues.length > 0) {
        enums.set(field.enumName || `${table.tableName}_${field.name}_enum`, field.enumValues);
      }
    });
  });
  
  for (const [enumName, values] of enums.entries()) {
    sql += `-- 创建${enumName}枚举类型\n`;
    sql += `DO $$\n`;
    sql += `BEGIN\n`;
    sql += `  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = '${enumName}') THEN\n`;
    sql += `    CREATE TYPE ${enumName} AS ENUM ('${values.join("', '")}');\n`;
    sql += `  END IF;\n`;
    sql += `END$$;\n\n`;
  }
  
  return sql;
}

// 执行生成
generateTableSQL();